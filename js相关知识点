数组中：split("")将字符串转化为数组， reverse()反转数组中的内容，join("")将数组转换为字符串
二分查找（提高查找效率，但前提是数组为有序数组。比如在数组中找到某个值，判断数组是否是对称数组）
var low = 0; var high = arr.length-1; var mid = (low+high)/2; 通过for循环，不断改变low和high的值（low+i; high-i）
function test(arr){
  if(arr==null){
    return false;
  }
  if(arr instanceOf Array){
    var low = 0;
    high = arr.length-1;  
    for(var i=0;i<arr.length;i++){
      if(arr[low+i] != arr[high-i]){
        return false;
      }
    }
    return true;
  }
}
//优化，省去没必要的循环
循环时，如果知道循环的次数，就用for循环；如果不确定循环次数，就用while循环
function test(arr){
  if(arr==null){
    return false;
  }
  if(arr instanceOf Array){
    var low = 0;
    high = arr.length-1;  
    while(true){
      if(low>high){
        break;
      }
      if(arr[low] != arr[high]){
        return false;
      }
      low++;
      high--;
    }
   return true;
  }
}
判断子串在原串第一次出现的位置  （其实就是indexOf的内部实现逻辑）
function test(origin,sub){
  if(!origin || !sub || origin.length==0 || sub.length){
    return -1;
  }
  for(var i=0;i<origin.length-sub.length+1;i++){
    for(var j=0;j<sub.length;j++){
      if(sub[j] != origin[i+j]){  //i决定从哪个位置开始比
        break;
      }
      if(j==sub.length-1){
        return i;
      }
    }    
  }
  return -1; //所有循环都走完，没有找到，返回-1
}
查找数组中有最大连续增长子序列的长度
var max = 1;  //记录所查过得最大字串的长度
var nowMax = 1; //当前所查子串的长度
for(var i=0; i<arr.length;i++){
  if(arr[i] - arr[i-1] > 0){
    nowMax ++;
  }else{
    max = nowMax > max ? nowMax : max;
    nowMax = 1;
  }
}
//处理数组中最后一个子序列是增长出来的
max = nowMax > max ? nowMax : max;
return max;

柯里化 ---- call 和 apply 的应用
function sum(){
  var sum = 0;
  for(var i=0; i<arguments.length;i++){
    sum += arguments[i];
  }
  return sum;
}
//函数 参数是函数  返回一个函数  这个函数本身是一个高阶函数
function returnDeal(func){
  //接收参数(从第一位之后往下截)
  var arg = [].slice.call(arguments,1) //通过call，使this指向arguments(而此时的arguments是returnDeal里的10,20,30)
   //arg(永远都是10,20,30。形成了一个闭包)
  return function(){
    //执行func(其实func就是sum函数，执行累加功能)
    var _arg = arg.concat([].slice.call(arguments))  //此时arguments是在调用newSum时传入的参数，即30,40,50 （concat把参数10,20,30和30,40,50连接起来）
    return func.apply(window,_arg);
  }
}
var newSum = returnDeal(sum,10,20,30)
newSum(30,40,50);
